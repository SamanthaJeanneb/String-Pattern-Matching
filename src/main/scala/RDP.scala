/*
    Samantha Brown
    csc 344 Fall 2024

    Scala Project
 */
object RDP {

  // Entry method to initiate the parsing process for a given input string
  def parse(input: String): Exp = {
    val tokens = tokenize(input)  // Tokenizes the input string into a list of tokens
    val pResult = parse_E(tokens) // Begins parsing using the parse_E function, which starts from the E (expression) rule
    val tree = pResult._1         // The first element of the result tuple is the parsed expression tree
    val rem = pResult._2          // The second element is the remaining unprocessed tokens

    // Checks if parsing has consumed all tokens, meaning the input has been fully parsed
    if rem.head == Token.Tok_End then
      tree                         // If parsing is successful, return the generated expression tree
    else
      throw new Exception("Illegal parse_E") // Throws an error if any tokens remain, indicating a parsing issue
  }

  // Parses an expression (E), allowing alternation ('|') operations
  def parse_E(toks: List[Token]): (Exp, List[Token]) = {
    val tRes = parse_T(toks)        // Parses a term (T) as the first part of the expression
    val tTree = tRes._1             // Extracts the expression tree generated by parse_T
    val rest = tRes._2              // Remaining tokens after parsing the term

    val next = lookahead(rest)      // Looks at the next token without removing it from the list
    if next == Token.Tok_OR then    // Checks if the next token is an OR (|), indicating alternation
      val restOr = matchToken(Token.Tok_OR, rest) // Consumes the OR token
      val eRes = parse_E(restOr)    // Recursively parses another expression after the OR
      (Alternation(tTree, eRes._1), eRes._2) // Creates an Alternation node combining both parts
    else
      (tTree, rest)                 // Returns the term alone if no alternation is found
  }

  // Parses a term (T), which is a sequence of factors (F) that may be concatenated
  def parse_T(tokens: List[Token]): (Exp, List[Token]) = {
    val fRes = parse_F(tokens)      // Parses a factor (F) as the first part of the term
    val fTree = fRes._1             // Extracts the expression tree generated by parse_F
    val restFact = fRes._2          // Remaining tokens after parsing the factor

    val next = lookahead(restFact)  // Looks ahead at the next token
    if next.isInstanceOf[Token.Tok_Char] || next == Token.Tok_LPAREN then
      // If the next token is a character or left parenthesis, we expect concatenation
      val tRes = parse_T(restFact)  // Recursively parses the next term for concatenation
      (Concat(fTree, tRes._1), tRes._2) // Creates a Concat node combining both parts
    else
      (fTree, restFact)             // Returns the factor alone if no concatenation is found
  }

  // Parses a factor (F), which may be an atom (A) followed by an optionality indicator ('?')
  def parse_F(tokens: List[Token]): (Exp, List[Token]) = {
    val aRes = parse_A(tokens)      // Parses an atom (A) as the core component of the factor
    val aTree = aRes._1             // Extracts the expression tree generated by parse_A
    val restAtom = aRes._2          // Remaining tokens after parsing the atom

    val next = lookahead(restAtom)  // Looks ahead at the next token
    if next == Token.Tok_Q then     // Checks if the next token is a question mark '?', indicating optionality
      val restQ = matchToken(Token.Tok_Q, restAtom) // Consumes the '?' token
      (Optional(aTree), restQ)      // Wraps the atom in an Optional node and returns
    else
      (aTree, restAtom)             // Returns the atom alone if no '?' is found
  }

  // Parses an atom (A), which could be a single character or a parenthesized expression
  def parse_A(toks: List[Token]): (Exp, List[Token]) = {
    val next = lookahead(toks)      // Looks at the next token without consuming it
    if next.isInstanceOf[Token.Tok_Char] then
      // If the token is a character, creates a C (character) node
      val charVal = next.asInstanceOf[Token.Tok_Char].value // Extracts the character's value
      (C(charVal), matchToken(Token.Tok_Char(charVal), toks)) // Returns the character node and remaining tokens
    else if next == Token.Tok_LPAREN then
      // If the token is a left parenthesis '(', parses an enclosed expression
      val rem1 = matchToken(Token.Tok_LPAREN, toks) // Consumes the '(' token
      val eRes = parse_E(rem1)          // Parses the expression within the parentheses
      if lookahead(eRes._2) == Token.Tok_RPAREN then
        // Ensures the expression is closed with a right parenthesis ')'
        (eRes._1, matchToken(Token.Tok_RPAREN, eRes._2)) // Returns the parsed expression and remaining tokens
      else
        throw new Exception("missing parenthesis") // Throws an error if a closing parenthesis is missing
    else
      throw new Exception("Illegal parse_A") // Throws an error if an invalid token is encountered in parse_A
  }

  // Utility function that returns the first token in a list without consuming it
  def lookahead(l: List[Token]): Token = l match
    case List() => throw new Exception("no Tokens") // Throws an error if the list is empty
    case head :: tail => head                       // Returns the first token if the list is not empty

  // Consumes a token if it matches the expected token; otherwise, throws an error
  def matchToken(tok: Token, tokList: List[Token]): List[Token] = tokList match
    case head :: tail if tok == head => tail        // Returns the remaining tokens if the match is successful
    case _ => throw new Exception("token is not matched") // Throws an error if the tokens do not match
}
